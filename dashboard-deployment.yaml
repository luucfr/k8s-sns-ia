# Copyright 2017 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# General configuration shared across resources
app:
  mode: 'dashboard'
  image:
    pullPolicy: IfNotPresent
    pullSecrets: []
  scheduling:
    nodeSelector: {}
  security:
    csrfKey: ~
    securityContext:
      runAsNonRoot: true
      seccompProfile:
        type: RuntimeDefault
    containerSecurityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsUser: 1001
      runAsGroup: 2001
      capabilities:
        drop: ["ALL"]
    podDisruptionBudget:
      enabled: false
      minAvailable: 0
      maxUnavailable: 0
    networkPolicy:
      enabled: false
      ingressDenyAll: false
      spec: {}
  labels: {}
  annotations: {}
  priorityClassName: null
  settings:
    pinnedResources: []
  ingress:
    enabled: false
    hosts:
      - localhost
    ingressClassName: internal-nginx
    useDefaultIngressClass: false
    useDefaultAnnotations: true
    pathType: ImplementationSpecific
    path: /
    issuer:
      name: selfsigned
      scope: default
    tls:
      enabled: true
      secretName: ""
    labels: {}
    annotations: {}
  tolerations: []
  affinity: {}

auth:
  role: auth
  image:
    repository: docker.io/kubernetesui/dashboard-auth
    tag: 1.2.4
  scaling:
    replicas: 1
    revisionHistoryLimit: 10
  service:
    type: ClusterIP
    extraSpec: ~
  containers:
    ports:
      - name: auth
        containerPort: 8000
        protocol: TCP
    args: []
    env: []
    volumeMounts:
      - mountPath: /tmp
        name: tmp-volume
    resources:
      requests:
        cpu: 100m
        memory: 200Mi
      limits:
        cpu: 250m
        memory: 400Mi
  automountServiceAccountToken: true
  volumes:
    - name: tmp-volume
      emptyDir: {}
  nodeSelector: {}
  labels: {}
  annotations: {}
  serviceLabels: {}
  serviceAnnotations: {}

# API deployment configuration
api:
  role: api
  image:
    repository: docker.io/kubernetesui/dashboard-api
    tag: 1.11.1
  scaling:
    replicas: 1
    revisionHistoryLimit: 10
  service:
    type: ClusterIP
    extraSpec: ~
  containers:
    ports:
      - name: api
        containerPort: 8000
        protocol: TCP
    args: []
    env: []
    volumeMounts:
      - mountPath: /tmp
        name: tmp-volume
    resources:
      requests:
        cpu: 100m
        memory: 200Mi
      limits:
        cpu: 250m
        memory: 400Mi
  automountServiceAccountToken: true
  volumes:
    - name: tmp-volume
      emptyDir: {}
  nodeSelector: {}
  labels: {}
  annotations: {}
  serviceLabels: {}
  serviceAnnotations: {}

# WEB UI deployment configuration
web:
  role: web
  image:
    repository: docker.io/kubernetesui/dashboard-web
    tag: 1.6.2
  scaling:
    replicas: 1
    revisionHistoryLimit: 10
  service:
    type: ClusterIP
    extraSpec: ~
  containers:
    ports:
      - name: web
        containerPort: 8000
        protocol: TCP
    args: []
    env: []
    volumeMounts:
      - mountPath: /tmp
        name: tmp-volume
    resources:
      requests:
        cpu: 100m
        memory: 200Mi
      limits:
        cpu: 250m
        memory: 400Mi
  automountServiceAccountToken: true
  volumes:
    - name: tmp-volume
      emptyDir: {}
  nodeSelector: {}
  labels: {}
  annotations: {}
  serviceLabels: {}
  serviceAnnotations: {}

### Metrics Scraper
### Container to scrape, store, and retrieve a window of time from the Metrics Server.
### refs: https://github.com/kubernetes/dashboard/tree/master/modules/metrics-scraper
metricsScraper:
  enabled: true
  role: metrics-scraper
  image:
    repository: docker.io/kubernetesui/dashboard-metrics-scraper
    tag: 1.2.2
  scaling:
    replicas: 1
    revisionHistoryLimit: 10
  service:
    type: ClusterIP
    extraSpec: ~
  containers:
    ports:
      - containerPort: 8000
        protocol: TCP
    args: []
    env: []
    volumeMounts:
      - mountPath: /tmp
        name: tmp-volume
    resources:
      requests:
        cpu: 100m
        memory: 200Mi
      limits:
        cpu: 250m
        memory: 400Mi
    livenessProbe:
      httpGet:
        scheme: HTTP
        path: /
        port: 8000
      initialDelaySeconds: 30
      timeoutSeconds: 30
  automountServiceAccountToken: true
  volumes:
    - name: tmp-volume
      emptyDir: {}
  nodeSelector: {}
  labels: {}
  annotations: {}
  serviceLabels: {}
  serviceAnnotations: {}

## Required Kong sub-chart with DBless configuration to act as a gateway
## for our all containers.
kong:
  enabled: true
  env:
    dns_order: LAST,A,CNAME,AAAA,SRV
    plugins: 'off'
    nginx_worker_processes: 1
  ingressController:
    enabled: false
  manager:
    enabled: false
  dblessConfig:
    configMap: kong-dbless-config
  proxy:
    type: ClusterIP
    http:
      enabled: false

## Configuration pour le reverse proxy
reverseProxy:
  service:
    apiVersion: v1
    kind: Service
    metadata:
      name: reverse-proxy
      namespace: reverse-proxy
    spec:
      selector:
        app: reverse-proxy
      ports:
        - protocol: TCP
          port: 8000
          targetPort: 8000

  ingress:
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: reverse-proxy-ingress
      namespace: reverse-proxy
      annotations:
        traefik.ingress.kubernetes.io/router.entrypoints: web
        nginx.ingress.kubernetes.io/rewrite-target: /
    spec:
      rules:
      - host: cluster.ai.api.snsolutions.fr
        http:
          paths:
          - path: /dashboard
            pathType: Prefix
            backend:
              service:
                name: reverse-proxy
                port:
                  number: 8000